# Диаграммы работы функций высшего порядка

## 1. Общая концепция функций высшего порядка

```mermaid
graph TD
    A[Функция высшего порядка] --> B[Принимает функцию как аргумент]
    A --> C[Возвращает функцию как результат]
    A --> D[И то и другое]
    
    B --> E[Обрабатывает данные с помощью переданной функции]
    C --> F[Создает специализированные функции]
    D --> G[Комбинированное поведение]
    
    E --> H[map, filter, reduce]
    F --> I[Каррирование, фабрики функций]
    G --> J[Декораторы, композиция]
```

## 2. Функции, принимающие другие функции (на примере map)

```mermaid
sequenceDiagram
    participant A as Исходный массив
    participant HOF as Функция высшего порядка (map)
    participant F as Callback-функция
    participant R as Результирующий массив

    Note over A,HOF: Начальное состояние
    A->>HOF: [1, 2, 3, 4, 5]
    
    loop Для каждого элемента
        HOF->>F: Передает элемент (например: 1)
        Note over F: Выполняет преобразование<br/>x * 2
        F->>HOF: Возвращает результат (2)
        HOF->>R: Добавляет в результат
    end
    
    HOF->>R: Возвращает [2, 4, 6, 8, 10]
```

## 3. Процесс работы Array методов

```mermaid
flowchart TD
    A[Исходный массив] --> B{Выбор метода}
    
    B --> C[map]
    B --> D[filter]
    B --> E[reduce]
    B --> F[forEach]
    
    C --> C1[Применяет функцию к каждому элементу]
    C1 --> C2[Возвращает новый массив<br/>с преобразованными значениями]
    
    D --> D1[Проверяет условие для каждого элемента]
    D1 --> D2[Возвращает новый массив<br/>только с подходящими элементами]
    
    E --> E1[Накопитель + текущий элемент]
    E1 --> E2[Возвращает одно значение<br/>сумма/максимум/группировка]
    
    F --> F1[Выполняет функцию для каждого элемента]
    F1 --> F2[Возвращает undefined]
    
    C2 --> G[Результат]
    D2 --> G
    E2 --> G
    F2 --> H[Побочные эффекты]
```

## 4. Функции, возвращающие другие функции (замыкания)

```mermaid
graph LR
    A[Внешняя функция] --> B[Создает локальные переменные]
    B --> C[Возвращает внутреннюю функцию]
    C --> D[Внутренняя функция]
    D --> E[Имеет доступ к<br/>переменным внешней функции]
    E --> F[Замыкание]
    
    G[Вызов внешней функции] --> H[Создается контекст выполнения]
    H --> I[Возвращается функция]
    I --> J[Контекст сохраняется<br/>в замыкании]
```

## 5. Практический пример: createMultiplier

```mermaid
flowchart TD
    A[Вызов createMultiplier2] --> B[Создается контекст<br/>multiplier = 2]
    B --> C[Возвращается функция<br/>functionnumber]
    C --> D[double = функция]
    
    E[Вызов double5] --> F[Выполняется<br/>return number * multiplier]
    F --> G[multiplier = 2 из замыкания]
    G --> H[number = 5 из аргумента]
    H --> I[Результат: 10]
    
    J[Вызов createMultiplier3] --> K[Новый контекст<br/>multiplier = 3]
    K --> L[triple = функция]
    L --> M[triple5 → 15]
```

## 6. Цепочка функций высшего порядка

```mermaid
flowchart LR
    A[Исходные данные<br/>массив чисел] --> B[filter: x > 2]
    B --> C[Отфильтрованный массив<br/>3,4,5]
    C --> D[map: x * 2]
    D --> E[Преобразованный массив<br/>6,8,10]
    E --> F[reduce: a + b]
    F --> G[Конечный результат<br/>24]
    
    H[Функция-предикат] --> B
    I[Функция-трансформатор] --> D
    J[Функция-аккумулятор] --> F
```

## 7. Паттерн Стратегия с функциями высшего порядка

```mermaid
graph TD
    A[Клиентский код] --> B[processPayment]
    
    subgraph C [Стратегии оплаты]
        D[creditCardStrategy]
        E[paypalStrategy]
        F[cryptoStrategy]
    end
    
    B --> D
    B --> E
    B --> F
    
    D --> G[Выполняет логику карты]
    E --> H[Выполняет логику PayPal]
    F --> I[Выполняет логику крипто]
    
    G --> J[Успешный платеж]
    H --> J
    I --> J
```

## 8. Процесс композиции функций

```mermaid
flowchart LR
    A[Входные данные] --> B[Функция A]
    B --> C[Промежуточный результат]
    C --> D[Функция B]
    D --> E[Промежуточный результат]
    E --> F[Функция C]
    F --> G[Конечный результат]
    
    H[composeC, B, A] --> I[Новая функция]
    I --> J[Принимает данные<br/>выполняет A→B→C]
    
    K[Вход] --> L[compose функция]
    L --> M[Результат]
```

## 9. Работа с асинхронными функциями высшего порядка

```mermaid
sequenceDiagram
    participant C as Клиент
    participant HOF as withRetry
    participant F as Асинхронная функция
    participant R as Результат

    C->>HOF: Вызов с функцией и параметрами
    Note over HOF: Попытка 1
    
    loop Максимум 3 попытки
        HOF->>F: Вызов функции
        alt Успех
            F->>HOF: Результат
            HOF->>R: Возвращает результат
            break
        else Ошибка
            F->>HOF: Ошибка
            Note over HOF: Ожидание перед повторной попыткой
        end
    end
    
    alt Все попытки неудачны
        HOF->>C: Исключение
    end
```

## 10. Полный цикл работы функций высшего порядка

```mermaid
flowchart TD
    A[Проблема] --> B[Анализ]
    B --> C[Разбиение на маленькие функции]
    
    C --> D[Функции-трансформеры]
    C --> E[Функции-фильтры]
    C --> F[Функции-редьюсеры]
    C --> G[Функции-валидаторы]
    
    D --> H[Композиция функций]
    E --> H
    F --> H
    G --> H
    
    H --> I[Функция высшего порядка]
    I --> J[Обработка данных]
    J --> K[Чистый, читаемый код]
    K --> L[Легкое тестирование]
    L --> M[Простое обслуживание]
```

Эти диаграммы показывают, как функции высшего порядка:

1. **Абстрагируют** сложную логику
2. **Комбинируют** простые функции в сложное поведение
3. **Создают** специализированные функции из общих
4. **Обрабатывают** данные через цепочки преобразований
5. **Реализуют** паттерны проектирования простым способом

Ключевая идея: функции высшего порядка работают с другими функциями как с данными, что позволяет создавать гибкие и переиспользуемые конструкции.