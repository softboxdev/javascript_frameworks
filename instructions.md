
## **📚 УПРАЖНЕНИЕ 1: Базовый асинхронный action**

### **ПРИМЕР С РАЗБОРОМ:**

```javascript
// Создаем асинхронный action для загрузки списка товаров
export const fetchProducts = () => async (dispatch) => {
  // ↑ export - ключевое слово: делает функцию доступной для импорта в других файлах
  // ↑ const - объявление константы: создает неизменяемую переменную
  // ↑ fetchProducts - имя нашей асинхронной функции
  // ↑ () - параметры функции: здесь пустые скобки, значит функция не принимает параметров
  // ↑ => - стрелочная функция: современный синтаксис объявления функций в JavaScript
  // ↑ async - модификатор: указывает что функция содержит асинхронные операции
  // ↑ (dispatch) - параметры: Redux автоматически передает функцию dispatch
  
  try {
    // ↑ try - начало блока: пытаемся выполнить код внутри этих скобок
    // ↑ { - открывающая фигурная скобка: начало блока try
    
    // 1. Отправляем action о начале загрузки
    dispatch(loadProductsStart());
    // ↑ dispatch - функция: отправляет action в Redux хранилище
    // ↑ loadProductsStart - action creator: функция которая создает action объект
    // ↑ () - вызов функции: выполняем функцию loadProductsStart
    
    // 2. Выполняем HTTP запрос к API
    const response = await fetch('https://api.example.com/products');
    // ↑ const - объявление константы: создаем переменную response
    // ↑ response - имя переменной: будет хранить ответ от сервера
    // ↑ = - оператор присваивания: сохраняем значение справа в переменную слева
    // ↑ await - ключевое слово: ЖДЕМ завершения операции fetch перед продолжением
    // ↑ fetch - встроенная функция: выполняет HTTP запрос
    // ↑ 'https://...' - строка: URL адрес API endpoint
    // ↑ ; - точка с запятой: конец инструкции
    
    // 3. Проверяем успешность HTTP запроса
    if (!response.ok) {
      // ↑ if - условный оператор: если условие истинно, выполняем блок кода
      // ↑ ! - логическое НЕ: инвертирует значение (true становится false)
      // ↑ response.ok - свойство: true если HTTP статус 200-299
      // ↑ { - начало блока: код который выполнится если условие истинно
      
      throw new Error('Failed to load products');
      // ↑ throw - оператор: выбрасывает (создает) ошибку
      // ↑ new - оператор: создает новый экземпляр объекта
      // ↑ Error - встроенный класс: представляет ошибку в JavaScript
      // ↑ 'Failed...' - строка: сообщение об ошибке
    }
    
    // 4. Преобразуем ответ в JSON формат
    const products = await response.json();
    // ↑ const - объявление константы
    // ↑ products - имя переменной: будет хранить массив товаров
    // ↑ = - оператор присваивания
    // ↑ await - ключевое слово: ЖДЕМ преобразования ответа в JSON
    // ↑ response.json() - метод: читает тело ответа и преобразует его в JavaScript объект
    // ↑ () - вызов метода
    
    // 5. Отправляем action с загруженными данными
    dispatch(loadProductsSuccess(products));
    // ↑ dispatch - отправка action в Redux
    // ↑ loadProductsSuccess - action creator для успешной загрузки
    // ↑ (products) - аргумент: передаем данные товаров в action creator
    
  } catch (error) {
    // ↑ catch - блок: выполняется если в try произошла ошибка
    // ↑ (error) - параметр: объект ошибки который мы перехватили
    // ↑ { - начало блока catch
    
    // 6. Обрабатываем ошибку
    dispatch(loadProductsFailure(error.message));
    // ↑ dispatch - отправка action
    // ↑ loadProductsFailure - action creator для ошибки загрузки
    // ↑ (error.message) - аргумент: передаем текст ошибки
    // ↑ error.message - свойство: содержит сообщение об ошибке
  }
  // ↑ } - конец блока catch
};
// ↑ } - конец асинхронной функции
```

---

## **🎯 УПРАЖНЕНИЯ ДЛЯ ЗАКРЕПЛЕНИЯ:**

### **ЗАДАНИЕ 1: Создайте асинхронный action для авторизации**

```javascript
// ЗАДАЧА: Создайте асинхронный action для входа пользователя
// Он должен принимать email и password, делать запрос к API
// и обрабатывать успех/ошибку

// TODO: Напишите код здесь
export const loginUser = (email, password) => async (dispatch) => {
  // Ваш код здесь
};
```

**ПОДСКАЗКА ДЛЯ РЕШЕНИЯ:**
```javascript
// Пример структуры:
try {
  // 1. Начало загрузки
  // 2. HTTP POST запрос к /api/login
  // 3. Проверка response.ok
  // 4. Преобразование в JSON
  // 5. Успешный dispatch с данными пользователя
} catch (error) {
  // 6. Dispatch ошибки
}
```

### **ЗАДАНИЕ 2: Асинхронный action с таймаутом**

```javascript
// ЗАДАЧА: Создайте action который ждет 3 секунды перед выполнением

export const delayedAction = () => {
  // Ваш код здесь
};
```

### **ЗАДАНИЕ 3: Цепочка запросов**

```javascript
// ЗАДАЧА: Сначала загрузите пользователя, затем его заказы

export const fetchUserAndOrders = (userId) => {
  // Ваш код здесь
};
```

---

## **📚 УПРАЖНЕНИЕ 2: Работа с несколькими действиями**

### **ПРИМЕР С РАЗБОРОМ:**

```javascript
// Слайс для управления состоянием загрузки
const productsSlice = createSlice({
  // ↑ const - объявление константы
  // ↑ productsSlice - переменная которая хранит созданный слайс
  // ↑ = - оператор присваивания
  // ↑ createSlice() - функция из Redux Toolkit: создает слайс (редьюсер + actions)
  
  name: 'products',
  // ↑ name - свойство: уникальное имя слайса (строка)
  // ↑ 'products' - значение: имя для этого слайса в хранилище
  
  initialState: {
    // ↑ initialState - свойство: начальное состояние слайса
    // ↑ { - начало объекта начального состояния
    
    items: [],
    // ↑ items - свойство: массив для хранения товаров
    // ↑ [] - пустой массив: начальное значение
    
    loading: false,
    // ↑ loading - свойство: флаг указывает идет ли загрузка
    // ↑ false - булево значение: изначально загрузка не идет
    
    error: null
    // ↑ error - свойство: для хранения сообщения об ошибке
    // ↑ null - специальное значение: означает "ничего"
    
  }, // ↑ } - конец объекта initialState
  // ↑ , - запятая: разделяет свойства в объекте
  
  reducers: {
    // ↑ reducers - свойство: объект содержащий функции-редьюсеры
    // ↑ { - начало объекта reducers
    
    loadProductsStart: (state) => {
      // ↑ loadProductsStart - имя редьюсера (action creator)
      // ↑ (state) - параметр: текущее состояние слайса
      // ↑ => - стрелочная функция
      // ↑ { - начало функции
      
      state.loading = true;
      // ↑ state - параметр: текущее состояние
      // ↑ .loading - обращение к свойству loading
      // ↑ = - присваивание
      // ↑ true - устанавливаем флаг загрузки в true
      
      state.error = null;
      // ↑ state.error - свойство error в состоянии
      // ↑ = - присваивание
      // ↑ null - очищаем предыдущие ошибки
      
    }, // ↑ } - конец функции, запятая для разделения
    
    loadProductsSuccess: (state, action) => {
      // ↑ loadProductsSuccess - имя редьюсера
      // ↑ (state, action) - параметры: состояние и action объект
      
      state.loading = false;
      // ↑ state.loading - флаг загрузки
      // ↑ = false - устанавливаем в false так как загрузка завершена
      
      state.items = action.payload;
      // ↑ state.items - массив товаров в состоянии
      // ↑ = - присваивание
      // ↑ action.payload - данные из action (массив товаров)
      
    },
    
    loadProductsFailure: (state, action) => {
      state.loading = false;
      state.error = action.payload;
    }
    
  } // ↑ } - конец объекта reducers
}); // ↑ } - конец createSlice, закрывающая скобка и точка с запятой

// Экспортируем actions
export const { 
  loadProductsStart, 
  loadProductsSuccess, 
  loadProductsFailure 
} = productsSlice.actions;
// ↑ export - делает перечисленные функции доступными для импорта
// ↑ const - объявление констант
// ↑ { ... } - деструктуризация: извлекаем actions из productsSlice.actions
// ↑ productsSlice.actions - свойство: содержит автоматически созданные action creators

// Экспортируем редьюсер
export default productsSlice.reducer;
// ↑ export default - экспорт по умолчанию
// ↑ productsSlice.reducer - свойство: содержит готовый редьюсер
```

---

## **🎯 УПРАЖНЕНИЯ ДЛЯ ЗАКРЕПЛЕНИЯ 2:**

### **ЗАДАНИЕ 4: Создайте слайс для корзины покупок**

```javascript
// ЗАДАЧА: Создайте слайс для управления корзиной с товарами
// Должен содержать: массив items, общую сумму, флаг загрузки

const cartSlice = createSlice({
  name: 'cart',
  initialState: {
    // TODO: определите начальное состояние
  },
  reducers: {
    // TODO: создайте редьюсеры для:
    // - addToCart (добавить товар)
    // - removeFromCart (удалить товар)
    // - updateQuantity (изменить количество)
    // - clearCart (очистить корзину)
  }
});
```

### **ЗАДАНИЕ 5: Асинхронный action для корзины**

```javascript
// ЗАДАЧА: Создайте асинхронный action для отправки заказа

export const submitOrder = (orderData) => async (dispatch) => {
  // TODO: реализуйте логику:
  // 1. Начало отправки
  // 2. POST запрос к /api/orders
  // 3. Обработка успеха/ошибки
  // 4. Очистка корзины при успехе
};
```

---

## **📚 УПРАЖНЕНИЕ 3: Использование getState**

### **ПРИМЕР С РАЗБОРОМ:**

```javascript
export const addProductToCart = (productId) => async (dispatch, getState) => {
  // ↑ (dispatch, getState) - второй параметр: функция для получения текущего состояния
  
  try {
    // Получаем текущее состояние всего Redux хранилища
    const state = getState();
    // ↑ const - объявление константы
    // ↑ state - переменная: будет хранить все состояние приложения
    // ↑ = - присваивание
    // ↑ getState() - функция: возвращает текущее состояние хранилища
    // ↑ () - вызов функции без параметров
    
    // Проверяем существует ли уже товар в корзине
    const existingCartItem = state.cart.items.find(item => item.id === productId);
    // ↑ const - объявление константы
    // ↑ existingCartItem - переменная: найденный товар или undefined
    // ↑ = - присваивание
    // ↑ state.cart - обращение к части состояния "cart"
    // ↑ .items - обращение к массиву товаров в корзине
    // ↑ .find() - метод массива: ищет первый элемент удовлетворяющий условию
    // ↑ item => - стрелочная функция для каждого элемента массива
    // ↑ item.id - свойство id текущего товара
    // ↑ === - строгое равенство
    // ↑ productId - ID товара который мы хотим добавить
    
    if (existingCartItem) {
      // ↑ if - условие: если товар уже есть в корзине
      // ↑ existingCartItem - будет true если товар найден
      
      // Увеличиваем количество существующего товара
      dispatch(updateCartItemQuantity(productId, existingCartItem.quantity + 1));
      // ↑ dispatch - отправка action
      // ↑ updateCartItemQuantity - action creator для обновления количества
      // ↑ (productId, ...) - первый аргумент: ID товара
      // ↑ existingCartItem.quantity - текущее количество товара
      // ↑ + 1 - увеличиваем на 1
      
    } else {
      // ↑ else - блок: если товара нет в корзине (условие if ложно)
      
      // Получаем информацию о товаре из состояния products
      const product = state.products.items.find(p => p.id === productId);
      // ↑ const - объявление константы
      // ↑ product - переменная: информация о товаре
      // ↑ = - присваивание
      // ↑ state.products - часть состояния с товарами
      // ↑ .items - массив всех товаров
      // ↑ .find() - поиск товара по ID
      // ↑ p => p.id === productId - условие поиска
      
      if (product) {
        // ↑ if - условие: если товар найден в каталоге
        
        // Добавляем новый товар в корзину
        dispatch(addToCart(product));
        // ↑ dispatch - отправка action
        // ↑ addToCart - action creator для добавления товара
        // ↑ (product) - передаем объект товара
        
      } else {
        // ↑ else - блок: если товар не найден в каталоге
        
        // Ошибка: товар не существует
        throw new Error('Product not found');
        // ↑ throw - создаем ошибку
        // ↑ new Error - новый объект ошибки
        // ↑ 'Product not found' - сообщение об ошибке
      }
    }
    
  } catch (error) {
    // ↑ catch - блок: перехват ошибок
    // ↑ (error) - объект ошибки
    
    // Обрабатываем ошибку
    console.error('Failed to add product to cart:', error.message);
    // ↑ console.error - вывод ошибки в консоль
    // ↑ 'Failed...' - сообщение для разработчика
    // ↑ error.message - текст ошибки
    
    dispatch(showNotification('Failed to add product to cart'));
    // ↑ dispatch - отправка action
    // ↑ showNotification - action creator для показа уведомления
    // ↑ 'Failed...' - текст уведомления для пользователя
  }
};
```

---

## **🎯 ФИНАЛЬНЫЕ УПРАЖНЕНИЯ:**

### **ЗАДАНИЕ 6: Комплексный асинхронный action**

```javascript
// ЗАДАЧА: Создайте action который:
// 1. Проверяет авторизацию пользователя
// 2. Если не авторизован - показывает ошибку
// 3. Если авторизован - загружает персональные рекомендации
// 4. Обновляет историю просмотров

export const loadPersonalizedData = () => async (dispatch, getState) => {
  // TODO: Ваш код здесь
};
```

### **ЗАДАНИЕ 7: Обработка нескольких ошибок**

```javascript
// ЗАДАЧА: Создайте action с разными типами ошибок

export const complexOperation = (data) => async (dispatch) => {
  // TODO: Обработайте разные сценарии:
  // - Сетевая ошибка
  // - Ошибка валидации данных
  // - Ошибка авторизации
  // - Успешное выполнение
};
```

---

## **📋 ЧЕК-ЛИСТ ДЛЯ САМОПРОВЕРКИ:**

После выполнения упражнений проверьте, что вы понимаете:

- [ ] Что делает ключевое слово `async`
- [ ] Для чего нужен `await` 
- [ ] Как работает `dispatch` в асинхронных actions
- [ ] Зачем нужен блок `try/catch`
- [ ] Как использовать `getState()`
- [ ] Как создавать и экспортировать actions
- [ ] Как обрабатывать разные сценарии ошибок
- [ ] Как работать с цепочками запросов

Каждое упражнение постепенно усложняется, чтобы вы могли уверенно освоить асинхронные actions в Redux! 🚀